---
layout: post
title:  "Effective Planning: Lessons from Tournament Chess"
date:   2017-06-21 09:00:00 -0400
categories: development
---

All chess grandmasters are routinely asked how many moves they plan ahead and the pithiest response to that question came from the late Cuban world champion Jos√© Capablanca who answered "Only one, but it's always the right one."

Creating software, like tournament chess, is a delicate game. In both, the incredible [number of possible outcomes](https://en.wikipedia.org/wiki/Shannon_number) makes it wholly infeasible to know at the outset everything that will unfold. Nevertheless we are compelled by time pressure, be it a chess clock or deadline, to move, attempting to respond accurately to an ever-changing landscape built from our previous decisions and those of others.

So we must find a balance in how long we plan. Too little and we will make a blunder. Too much and we will forfeit on time.

In chess, the right balance depends on the state of both the board, which varies in complexity, and the clock, which varies in available seconds. During championship matches, grandmasters will prepare openings they find favorable given their style and opponent so that they may initially advance quickly, leaving room for the [middlegame](https://en.wikipedia.org/wiki/Chess_middlegame) when they will begin to encounter novel positions requiring further examination. They will hasten their play when they have limited time remaining, perhaps because they calculated deeply on the 24th move ensuring the soundness of a [brilliant rook sacrifice](http://www.chessgames.com/perl/chessgame?gid=1011478) or because they are playing a [lightning round](https://youtu.be/3nYwTWycVSM?t=3s).

Similarly, the right balance in software depends on the condition of the project and its schedule. Just as grandmasters will prepare openings that account for themselves and their opponent, seasoned developers will choose what tools to use based on their past experience and the general functions of the desired program so that may add boilerplate code quickly, focusing their attention later on when implementing logic specific to the particularities of the application. Also like grandmasters, they will act quicker when facing tighter timelines, perhaps because they were forced to handle a tricky set of permutations or because they are participating in a hackathon.

Effective planning for a software project is not something done once -- it is a constant process. We should learn from the greatest chess players, adjusting how long we take before making our next move based on the situation we are faced with.
